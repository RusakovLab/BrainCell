
// The next "declarations" are needed just to bind the template external-s at the file sourcing time
//  Only one of these two will be defined and used
obfunc createNeuronNanoBranch() { codeContractViolation() }
obfunc createAstrocyteNanoBranch() { codeContractViolation() }
//  These proc-s will be defined after the file sourcing and before the first call
proc reseedAstrocyteGapJuncs() { codeContractViolation() }
proc deleteAstrocyteGapJuncs() { codeContractViolation() }
proc reseedNeuronSyns() { codeContractViolation() }
proc deleteNeuronSyns() { codeContractViolation() }

objref manageAndRunWidget

isFirstReseeding = 1

NumberNanoBranches = -1

{ load_file("Exported/CreateNanoRefs_Exported_deprecated.hoc") }

if (isAstrocyteOrNeuron) {
    load_file("Astrocyte/AstrocyteNanoBranch.hoc")
    objref spineNeckDiamCache
} else {
    load_file("Neuron/NeuronNanoBranch.hoc")
    load_file("../Managers/SynManager/Exported/SpineNeckDiamCache.hoc")
}

{ load_file("../NanoSeeding/NanoSeedingLoads.hoc") }


begintemplate NanoBranchesManager
    
    public reseedBranches, reseedBranchesWithLastUsedArgs, updateBranches, deleteBranches
    
    // Keeping this list "public" even though the name doesn't appear explicitly anywhere outside this template.
    // It turns out, NEURON accesses it via reflection (implicitly) when user selects
    //  Tools -> Distributed Mechanisms -> Viewers -> Shape Name
    // and then double clicks on any nanogeometry section in the list.
    public nanoBranches_flat
    
    public maxNumBranchesPerDend
    
    external seededDendrite_ref, NumberNanoBranches
    external isAstrocyteOrNeuron, isFirstReseeding
    external mwh, rngUtils, math, nanoGeomSeedingDensityHelper
    external eachSecInList, eachItemInList
    external manageAndRunWidget
    
    external createAstrocyteNanoBranch, createNeuronNanoBranch, createRefsForNanoGeometry_deprecated
    external reseedAstrocyteGapJuncs, deleteAstrocyteGapJuncs
    external reseedNeuronSyns, deleteNeuronSyns, spineNeckDiamCache
    external initVoltage
    
    // Flat List of all AstrocyteNanoBranch or NeuronNanoBranch
    // !! merge this with the logic from Exported/CreateNanoRefs_Exported_deprecated.hoc
    objref nanoBranches_flat
    
    objref randomBranchSeeder 
    
    maxNumBranchesPerDend = -1
    
    objref lastUsedArgs
    
    
    // Initialization of this singleton template
    proc init() { local inf
        maxNumBranchesPerDend = $1
        
        nanoBranches_flat = new List()
        randomBranchSeeder = rngUtils.getFor_nano_branchSeeder()
        
        inf = math.inf
        variable_domain(&maxNumBranchesPerDend, 0, inf)
    }
    
    // Reseed dendrites with nanobranches
    // $o1 - The Vector of args passed to *NanoBranch template
    // Other inputs: seededDendrite_ref (taken from the top level) etc.
    // !!! keep in sync with CreateDefaultGapJuncs.hoc -> reseedAstrocyteGapJuncs and GapJuncGroup.applyChangesToLoc
    proc reseedBranches() { local connectionPoint, minSeedingDistance, controlFactor, invNormFactor, slotIdx localobj args, nil
        args = $o1
        
        lastUsedArgs = args
        
        if (manageAndRunWidget != nil) {
            manageAndRunWidget.onNanoReseedOrUpdateHandler(1)
        }
        
        mwh.showPleaseWaitBox("Reseeding nanostructures.")
        {
            if (!isFirstReseeding) {
                deleteBranches()
            }
            
            for eachSecInList(seededDendrite_ref) {
                for slotIdx = 0, maxNumBranchesPerDend - 1 {
                    connectionPoint = slotIdxToConnectionPoint(slotIdx)
                    minSeedingDistance = nanoGeomSeedingDensityHelper.getMinSeedingDistance(connectionPoint)
                    controlFactor = minSeedingDistance * maxNumBranchesPerDend
                    invNormFactor = L / controlFactor                           // !! this can be > 1
                    if (randomBranchSeeder.uniform(0, 1) < invNormFactor) {     // !! use .repick() for performance
                        createInitAndConnectOneBranch(slotIdx, args)
                    }
                }
            }
            
            // !! is this correct place?
            // !! deprecated: collect the references when creating sections rather than search for sections with regex afterwards
            createRefsForNanoGeometry_deprecated()
            
            // !! it would be better to init the voltage just in nanogeometry
            initVoltage()
            
            if (isAstrocyteOrNeuron) {
                reseedAstrocyteGapJuncs()
            } else {
                spineNeckDiamCache.cacheAllDiams()
                if (!isFirstReseeding) {
                    reseedNeuronSyns()
                }
            }
        }
        mwh.hidePleaseWaitBox()
        
        isFirstReseeding = 0
        NumberNanoBranches = nanoBranches_flat.count()
        
        print "NumberNanoBranches: ", NumberNanoBranches    // !!
    }
    
    // Reseed dendrites with nanobranches using the same arguments as the last time
    // Inputs: seededDendrite_ref (taken from the top level) etc.
    proc reseedBranchesWithLastUsedArgs() {
        reseedBranches(lastUsedArgs)
    }
    
    // Update nanobranches geometry without reseeding
    // $o1 - The Vector of args passed to *NanoBranch template
    proc updateBranches() { localobj args, nanoBranch, nil
        args = $o1
        
        if (manageAndRunWidget != nil) {
            manageAndRunWidget.onNanoReseedOrUpdateHandler(0)
        }
        
        for eachItemInList(nanoBranch, nanoBranches_flat) {
            nanoBranch.update(args)
        }
        
        if (!isAstrocyteOrNeuron) {
            spineNeckDiamCache.cacheAllDiams()
        }
    }
    
    // Delete all nanobranches
    proc deleteBranches() {
        if (isAstrocyteOrNeuron) {
            // !!! would it make sense to delete only a subset of gap juncs located on or connected to the deleted nanogeometry?
            deleteAstrocyteGapJuncs()
        } else {
            deleteNeuronSyns()
        }
        
        // !! would it make sense to add some validation code to unref() procs of the destructed templates to check whether something external is connected?
        nanoBranches_flat.remove_all()
        
        // !! maybe clean up all refs to nanogeometry here just for safety
    }
    
    // All next staff is private
    
    
    // Create, initialize and connect to dendrite a new nanobranch
    // $1 - The index of a slot on that dendrite to connect the new nanobranch
    // $o2 - The Vector of args passed to *NanoBranch template
    // Other inputs: seededDendrite_ref (taken from the top level) etc.
    proc createInitAndConnectOneBranch() { local slotIdx, connectionPoint localobj args, newBranch
        slotIdx = $1
        args = $o2
        
        // Create and initialize one branch (sections, topology, geometry, biophysics)
        if (isAstrocyteOrNeuron) {
            newBranch = createAstrocyteNanoBranch(args)
        } else {
            newBranch = createNeuronNanoBranch(args)
        }
        nanoBranches_flat.append(newBranch)
        
        // Connect the new branch to this dendrite in this point
        connectionPoint = slotIdxToConnectionPoint(slotIdx)
        connect newBranch.root_ref.sec(0), connectionPoint
    }
    
    func slotIdxToConnectionPoint() { local slotIdx
        slotIdx = $1
        return slotIdx / maxNumBranchesPerDend
    }
    
endtemplate NanoBranchesManager
