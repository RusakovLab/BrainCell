
// !!
// BUGs:
//  callers are commented for:
//      * onMechInsert, onMechUninsert
//  implementations are missing or incomplete for:
//      * onNanoReseedOrUpdate (but we already lock the reseeding), onCompSplit, onCompMerge (the last two require changes in the stored VerbatimDistFuncHelper-s)
//  both caller and implementation are missing for:
//      * onRescanInMechManager (if we find out that user has made an inhomogen var homogen, then we need to remove the inhomogen model from this library)
//      * onChangingNsegInMechManager (if nseg was increased for already inhomogen comp, then we need to re-apply all inhomogen models again for this comp;
//          to achieve this, we'll have to store segmentationHelper in MechComp rather than in InhomAndStochTarget)
//      * onMovingDistanceCentre (we need to re-apply all inhomogen models)

// !! maybe create a few specialized iterators to simplify the loops in this template (e.g. eachActiveSpecVarInSyn or eachActiveStochSpecVarInDistMech)

begintemplate InhomAndStochLibrary
    
    public isInhomEnabledFor, isStochEnabledFor, onInhomApply, onStochApply, getInhomModelDataFor, getStochModelDataFor, onMakingVarHomogen, onStochDisable, onNanoReseedOrUpdate
    public isAnyNonVerbatimInhomVarsForDistMechs, getNumInhomVarsForDistMechs, getNumStochVarsForDistMechs, onMechInsert, onMechUninsert, onCompSplit, onCompMerge, onJustBeforeCompInhomStochBiophysImport, getBiophysVerbatimDistFuncHelperOrNil
    public getNumInhomVarsForTaps, getNumStochVarsForTaps, isAnyStochVarsForSyns, isAnyStochVars, onTapLocChange, onGapJuncStrucChange, onSynStrucChange, restoreToActiveIfWasMadeInactiveOnTapStrucChange
    public doesDistMechHaveAnyStochVars, doesThisVarHaveVerbatimOrNonVerbatimInhomModel, doesAnyInhomVarRequirePython, doesAnyStochVarRequirePython
    public findActiveSpecVar
    
    public activeSpecVars
    
    external mwh, math, dfc, sfc
    external stringsEqual, stringEmpty, concatenateTwoLists, codeContractViolation
    external pyObj
    external eachItemInList
    external enumGapJuncCompIdxs, enumSynCompIdxs
    
    objref activeSpecVars, inactiveSpecVars
    
    iterator eachActTapVarMakeInactIfNeeded() { codeContractViolation() }
    iterator eachInactTapVarMakeActIfNeeded() { codeContractViolation() }
    
    
    proc init() { local numArg localobj impRedObj, impActSpecVar
        activeSpecVars = new List()
        inactiveSpecVars = new List()
        
        numArg = numarg()
        if (numArg == 1) {
            // Load data from the imported reduced template
            impRedObj = $o1
            for eachItemInList(impActSpecVar, impRedObj.activeSpecVars) {
                activeSpecVars.append(new InhomAndStochTarget(impActSpecVar.varLibId, impActSpecVar))
            }
        } else if (numArg != 0) {
            codeContractViolation()
        }
    }
    
    // in: varLibId
    func isInhomEnabledFor() { localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($o1)
        if (actSpecVar == nil) {
            // Not found
            return 0
        }
        return actSpecVar.isInhom
    }
    
    // in: varLibId
    func isStochEnabledFor() { localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($o1)
        if (actSpecVar == nil) {
            // Not found
            return 0
        }
        return actSpecVar.isStoch
    }
    
    // in: varLibId, segmentationHelper, distFuncHelper, distFuncCatIdx, distFuncIdx
    proc onInhomApply() { localobj actSpecVar
        actSpecVar = findOrCreateActiveSpecVar($o1)
        actSpecVar.makeOrUpdateInhom($o2, $o3, $4, $5)
    }
    
    // in: varLibId, boundingHelper, stochFuncHelper, stochFuncCatIdx, stochFuncIdx
    // out: wasStoch
    func onStochApply() { local wasFoundOrCreated, wasStoch localobj actSpecVar
        actSpecVar = findOrCreateActiveSpecVar($o1, &wasFoundOrCreated)
        if (wasFoundOrCreated) {
            wasStoch = actSpecVar.isStoch
        } else {
            wasStoch = 0
        }
        actSpecVar.makeOrUpdateStoch($o2, $o3, $4, $5)
        return wasStoch
    }
    
    // in: varLibId
    // out: segmentationHelper, distFuncHelper, distFuncCatIdx, distFuncIdx
    proc getInhomModelDataFor() { localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($o1)
        if (actSpecVar == nil) {
            // Not found
            codeContractViolation()
        }
        if (!actSpecVar.isInhom) {
            codeContractViolation()
        }
        actSpecVar.getInhomModelData($o2, $o3, &$&4, &$&5)
    }
    
    // in: varLibId
    // out: boundingHelper, stochFuncHelper, stochFuncCatIdx, stochFuncIdx
    proc getStochModelDataFor() { localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($o1)
        if (actSpecVar == nil) {
            // Not found
            codeContractViolation()
        }
        if (!actSpecVar.isStoch) {
            codeContractViolation()
        }
        actSpecVar.getStochModelData($o2, $o3, &$&4, &$&5)
    }
    
    // !! major code dupl. with onStochDisable
    // in: varLibId
    proc onMakingVarHomogen() { local idx, isStochDisabledAsWell localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($o1, &idx)
        if (actSpecVar == nil) {
            // Not found
            return
        }
        isStochDisabledAsWell = actSpecVar.disableInhomOrStoch(1)
        if (isStochDisabledAsWell) {
            activeSpecVars.remove(idx)
        }
    }
    
    // !! major code dupl. with onMakingVarHomogen
    // in: varLibId
    // out: wasStoch
    func onStochDisable() { local idx, wasStoch, isInhomDisabledAsWell localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($o1, &idx)
        if (actSpecVar == nil) {
            // Not found
            return 0
        }
        wasStoch = actSpecVar.isStoch
        isInhomDisabledAsWell = actSpecVar.disableInhomOrStoch(0)
        if (isInhomDisabledAsWell) {
            activeSpecVars.remove(idx)
        }
        // !! do I need to restore the old value for the var here (i.e. the value before applying the stochasticity)?
        return wasStoch
    }
    
    // !! implement this method
    proc onNanoReseedOrUpdate() {
        // !! mwh.showNotImplementedWarning()
    }
    
    // !! uncomment the caller for this method once "restoreInhomogeneity" is implemented in InhomAndStochTarget for biophys mechs
    // in: compIdx, mechIdx
    proc onMechInsert() { local compIdx, mechIdx, inactSpecVarIdx localobj newActSpecVars, inactSpecVar, newActSpecVar
        compIdx = $1
        mechIdx = $2
        
        newActSpecVars = new List()
        
        // Given compartment and inserted mechanism, retrieve all old inhom and stoch models of its vars from the storage
        for (inactSpecVarIdx = inactiveSpecVars.count() - 1; inactSpecVarIdx >= 0; inactSpecVarIdx -= 1) {
            inactSpecVar = inactiveSpecVars.o(inactSpecVarIdx)
            if (!inactSpecVar.isDmOrTapPart) {
                continue
            }
            if (inactSpecVar.varLibId.compIdx != compIdx || inactSpecVar.varLibId.mechIdx != mechIdx) {
                continue
            }
            
            newActSpecVars.append(inactSpecVar)
            inactiveSpecVars.remove(inactSpecVarIdx)
        }
        
        // Apply all retrieved inhom models
        for eachItemInList(newActSpecVar, newActSpecVars) {
            if (newActSpecVar.isInhom) {
                newActSpecVar.restoreInhomogeneity()    // !! not implemented
            }
        }
        
        // Commit all the changes to the library
        concatenateTwoLists(activeSpecVars, newActSpecVars)
    }
    
    // !! uncomment the caller for this method
    // in: compIdx, mechIdx
    proc onMechUninsert() { local compIdx, mechIdx, actSpecVarIdx localobj actSpecVar
        compIdx = $1
        mechIdx = $2
        
        // Given compartment and uninserted mechanism, move all inhom and stoch models of its vars to the storage
        for (actSpecVarIdx = activeSpecVars.count() - 1; actSpecVarIdx >= 0; actSpecVarIdx -= 1) {
            actSpecVar = activeSpecVars.o(actSpecVarIdx)
            if (!actSpecVar.isDmOrTapPart) {
                continue
            }
            if (actSpecVar.varLibId.compIdx != compIdx || actSpecVar.varLibId.mechIdx != mechIdx) {
                continue
            }
            
            inactiveSpecVars.append(actSpecVar)
            activeSpecVars.remove(actSpecVarIdx)
        }
    }
    
    // !! finish the implementation for this method
    // in: splitCompIdx
    proc onCompSplit() { local splitCompIdx
        splitCompIdx = $1
        
        // Correct compIdx everywhere because we've inserted a new comp into mmAllComps
        correctCompIdxsAfterSplit(activeSpecVars, splitCompIdx)
        correctCompIdxsAfterSplit(inactiveSpecVars, splitCompIdx)
        
        // Copy all inhom and stoch models from src (splitCompIdx) to dst (splitCompIdx + 1) comp in activeSpecVars and inactiveSpecVars
        // !!
        
        // Update list_ref for src and dst in activeSpecVars and inactiveSpecVars
        // !!
        
        // !! mwh.showNotImplementedWarning()
    }
    
    // !! finish the implementation for this method
    // in: checkBoxStates, mergeCompIdx
    proc onCompMerge() { local mergeCompIdx, oldNumComps, idx, idx2, delCompIdx localobj checkBoxStates, delCompIdxs, compIdxMapFromOldToNew
        checkBoxStates = $o1
        mergeCompIdx = $2
        
        oldNumComps = checkBoxStates.size()
        
        // Delete inhom and stoch models for all merged comps (both activeSpecVars and inactiveSpecVars)
        delCompIdxs = new Vector()
        for idx = 0, oldNumComps - 1 {
            if (checkBoxStates.x(idx) && idx != mergeCompIdx) {
                delCompIdxs.append(idx)
            }
        }
        /* !!
        print "delCompIdxs:"
        delCompIdxs.printf("%8.4f\n")
        */
        deleteSpecVarsForMergedComps(activeSpecVars, delCompIdxs)
        deleteSpecVarsForMergedComps(inactiveSpecVars, delCompIdxs)
        
        // Correct compIdx everywhere because we've removed some comps in mmAllComps
        compIdxMapFromOldToNew = new Vector(oldNumComps)
        compIdxMapFromOldToNew.indgen()
        for idx = 0, delCompIdxs.size() - 1 {
            delCompIdx = delCompIdxs.x(idx)
            compIdxMapFromOldToNew.x(delCompIdx) = math.nan
            for idx2 = delCompIdx + 1, oldNumComps - 1 {
                compIdxMapFromOldToNew.x(idx2) -= 1
            }
        }
        /* !!
        print "compIdxMapFromOldToNew:"
        compIdxMapFromOldToNew.printf("%8.4f\n")
        */
        correctCompIdxsAfterMerge(activeSpecVars, compIdxMapFromOldToNew)
        correctCompIdxsAfterMerge(inactiveSpecVars, compIdxMapFromOldToNew)
        
        // Update list_ref for mergeCompIdx in activeSpecVars and inactiveSpecVars
        // !!
        
        // Restore inhomogeneity for mergeCompIdx in activeSpecVars
        // !!
        
        // !! mwh.showNotImplementedWarning()
    }
    
    // in: compIdx
    proc onJustBeforeCompInhomStochBiophysImport() { local actSpecVarIdx, cond localobj actSpecVar
        for (actSpecVarIdx = activeSpecVars.count() - 1; actSpecVarIdx >= 0; actSpecVarIdx -= 1) {
            actSpecVar = activeSpecVars.o(actSpecVarIdx)
            cond = (actSpecVar.isDmOrTapPart && actSpecVar.varLibId.compIdx == $1)
            if (!cond) {
                continue
            }
            cond = (actSpecVar.isInhom && pyObj.isAstrocyteSpecificInhomVar(actSpecVar.varLibId.compIdx, actSpecVar.varLibId.mechIdx, actSpecVar.varLibId.varType, actSpecVar.varLibId.varIdx, actSpecVar.varLibId.arrayIndex))
            // !! not sure if we need to remove (the current behaviour) or preserve the inhom model for g_pas in LargeGlia if user have applied some custom distance func to it
            //    which results in our inability to import Verbatim model from JSON file
            if (!cond) {
                activeSpecVars.remove(actSpecVarIdx)
            } else {
                // Remove stoch model, but preserve Verbatim inhom model to be re-scaled according to the new GPassive value imported as a part of biophysics
                // Keep in sync with py:BiophysJsonImportCore._importInhomModel
                actSpecVar.disableInhomOrStoch(0)
            }
        }
    }
    
    // in: compIdx, mechIdx, varType, varIdx, arrayIndex
    obfunc getBiophysVerbatimDistFuncHelperOrNil() { local distFuncCatIdx, distFuncIdx localobj varLibId, actSpecVar, segmentationHelper, distFuncHelper, nil
        varLibId = new VarLibId(0, $1, $2, $3, $4, $5)
        actSpecVar = findActiveSpecVar(varLibId)
        if (actSpecVar == nil) {
            // Not found
            return nil
        }
        if (!actSpecVar.isInhom) {
            return nil
        }
        actSpecVar.getInhomModelData(segmentationHelper, distFuncHelper, &distFuncCatIdx, &distFuncIdx)
        if (actSpecVar.distFuncIdx != dfc.verbatimDistFuncIdx) {
            return nil
        }
        if (segmentationHelper != nil) {
            codeContractViolation()
        }
        return distFuncHelper
    }
    
    func isAnyNonVerbatimInhomVarsForDistMechs() { local isFound localobj actSpecVar
        isFound = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            if (actSpecVar.isDmOrTapPart && actSpecVar.isInhom && actSpecVar.distFuncIdx != dfc.verbatimDistFuncIdx) {
                isFound = 1
                break
            }
        }
        return isFound
    }
    
    func getNumInhomVarsForDistMechs() {
        return getNumInhomOrStochVars(1, 1)
    }
    
    func getNumStochVarsForDistMechs() {
        return getNumInhomOrStochVars(1, 0)
    }
    
    func getNumInhomVarsForTaps() {
        return getNumInhomOrStochVars(0, 1)
    }
    
    func getNumStochVarsForTaps() {
        return getNumInhomOrStochVars(0, 0)
    }
    
    func isAnyStochVarsForSyns() { local isFound localobj actSpecVar
        isFound = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            if (actSpecVar.isDmOrTapPart) {
                continue
            }
            if (actSpecVar.isStoch) {
                // Don't replace with "return 1" because iterators cannot return a value (Segmentation violation)
                isFound = 1
                break
            }
        }
        return isFound
    }
    
    func isAnyStochVars() { local idx
        for idx = 0, activeSpecVars.count() - 1 {
            if (activeSpecVars.o(idx).isStoch) {
                return 1
            }
        }
        return 0
    }
    
    proc onTapLocChange() { localobj actSpecVar
        for eachItemInList(actSpecVar, activeSpecVars) {
            if (actSpecVar.isDmOrTapPart || !actSpecVar.isInhom) {
                continue
            }
            actSpecVar.restoreInhomogeneity()
        }
    }
    
    proc onGapJuncStrucChange() { local isCreateSomeGapJuncs, isExtOrInt, extOrIntCompIdx, doesNewGapJuncHavePtr, actCompIdx, isSkip, inactCompIdx localobj newInactSpecVars, newActSpecVars
        strdef mechNameOrEmpty_old, mechNameOrEmpty_new, inactMechName
        
        isCreateSomeGapJuncs = $1
        isExtOrInt = $2
        mechNameOrEmpty_old = $s3
        mechNameOrEmpty_new = $s4
        
        if (isExtOrInt) {
            extOrIntCompIdx = enumGapJuncCompIdxs.extGjPp
            doesNewGapJuncHavePtr = pyObj.ms_doesGapJuncHavePtr(mechNameOrEmpty_new)
        } else {
            extOrIntCompIdx = enumGapJuncCompIdxs.intGjPp
            doesNewGapJuncHavePtr = -1
        }
        
        // For each removed gap junc part (PP or ExtValue), move all inhom and stoch models to the storage
        newInactSpecVars = new List()
        for eachActTapVarMakeInactIfNeeded(&actCompIdx, &isSkip, newInactSpecVars) {
            if (actCompIdx == extOrIntCompIdx) {
                if (isCreateSomeGapJuncs && stringsEqual(mechNameOrEmpty_old, mechNameOrEmpty_new)) {
                    continue
                }
            } else if (isExtOrInt && actCompIdx == enumGapJuncCompIdxs.extGjExtValue) {
                if (isCreateSomeGapJuncs && doesNewGapJuncHavePtr) {
                    continue
                }
            } else {
                continue
            }
            
            isSkip = 0
        }
        
        // For each new gap junc part (PP or ExtValue), try to retrieve the old inhom and stoch models from the storage
        newActSpecVars = new List()
        for eachInactTapVarMakeActIfNeeded(&inactCompIdx, inactMechName, &isSkip, newActSpecVars) {
            if (inactCompIdx == extOrIntCompIdx) {
                if (!stringsEqual(inactMechName, mechNameOrEmpty_new)) {
                    continue
                }
            } else if (isExtOrInt && inactCompIdx == enumGapJuncCompIdxs.extGjExtValue) {
                if (!doesNewGapJuncHavePtr) {
                    continue
                }
            } else {
                continue
            }
            
            isSkip = 0
        }
        
        applyAllRetrievedInhomModelsAndCommitAllChangesToLibrary(newActSpecVars, newInactSpecVars)
    }
    
    proc onSynStrucChange() { local isSrcNameUnchanged, isTrgNameUnchanged, isSngNameUnchanged, isNetConPresent_new, isNetConPresenceUnchanged, actCompIdx, isSkip, inactCompIdx localobj newInactSpecVars, newActSpecVars
        strdef srcMechNameOrEmpty_old, trgMechNameOrEmpty_old, sngMechNameOrEmpty_old, srcMechNameOrEmpty_new, trgMechNameOrEmpty_new, sngMechNameOrEmpty_new, inactMechName
        
        srcMechNameOrEmpty_old = $s1
        trgMechNameOrEmpty_old = $s2
        sngMechNameOrEmpty_old = $s3
        srcMechNameOrEmpty_new = $s4
        trgMechNameOrEmpty_new = $s5
        sngMechNameOrEmpty_new = $s6
        
        isSrcNameUnchanged = stringsEqual(srcMechNameOrEmpty_old, srcMechNameOrEmpty_new)
        isTrgNameUnchanged = stringsEqual(trgMechNameOrEmpty_old, trgMechNameOrEmpty_new)
        isSngNameUnchanged = stringsEqual(sngMechNameOrEmpty_old, sngMechNameOrEmpty_new)
        isNetConPresent_new = stringEmpty(sngMechNameOrEmpty_new)
        isNetConPresenceUnchanged = (stringEmpty(sngMechNameOrEmpty_old) == isNetConPresent_new)
        
        // For each removed syn part (PP or NetCon), move all inhom and stoch models to the storage
        newInactSpecVars = new List()
        for eachActTapVarMakeInactIfNeeded(&actCompIdx, &isSkip, newInactSpecVars) {
            if (actCompIdx == enumSynCompIdxs.srcPp) {
                if (isSrcNameUnchanged) {
                    continue
                }
            } else if (actCompIdx == enumSynCompIdxs.trgPp) {
                if (isTrgNameUnchanged) {
                    continue
                }
            } else if (actCompIdx == enumSynCompIdxs.sngPp) {
                if (isSngNameUnchanged) {
                    continue
                }
            } else if (actCompIdx == enumSynCompIdxs.netCon) {
                if (isNetConPresenceUnchanged) {
                    continue
                }
            } else {
                codeContractViolation()
            }
            
            isSkip = 0
        }
        
        // For each new syn part (PP or NetCon), try to retrieve the old inhom and stoch models from the storage
        newActSpecVars = new List()
        for eachInactTapVarMakeActIfNeeded(&inactCompIdx, inactMechName, &isSkip, newActSpecVars) {
            if (inactCompIdx == enumSynCompIdxs.srcPp) {
                if (!stringsEqual(inactMechName, srcMechNameOrEmpty_new)) {
                    continue
                }
            } else if (inactCompIdx == enumSynCompIdxs.trgPp) {
                if (!stringsEqual(inactMechName, trgMechNameOrEmpty_new)) {
                    continue
                }
            } else if (inactCompIdx == enumSynCompIdxs.sngPp) {
                if (!stringsEqual(inactMechName, sngMechNameOrEmpty_new)) {
                    continue
                }
            } else if (inactCompIdx == enumSynCompIdxs.netCon) {
                if (!isNetConPresent_new) {
                    continue
                }
            } else {
                codeContractViolation()
            }
            
            isSkip = 0
        }
        
        applyAllRetrievedInhomModelsAndCommitAllChangesToLibrary(newActSpecVars, newInactSpecVars)
    }
    
    // in: varLibId
    proc restoreToActiveIfWasMadeInactiveOnTapStrucChange() { local idx localobj inactSpecVar
        for idx = 0, inactiveSpecVars.count() - 1 {
            inactSpecVar = inactiveSpecVars.o(idx)
            if (inactSpecVar.isEqual($o1)) {
                break
            }
        }
        if (idx == inactiveSpecVars.count()) {
            // Not found
            return
        }
        activeSpecVars.append(inactSpecVar)
        inactiveSpecVars.remove(idx)
    }
    
    // in: compIdx, mechIdx
    func doesDistMechHaveAnyStochVars() { local isFound localobj actSpecVar
        isFound = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            if (actSpecVar.isDmOrTapPart && actSpecVar.isStoch && actSpecVar.varLibId.compIdx == $1 && actSpecVar.varLibId.mechIdx == $2) {
                // Don't replace with "return 1"
                isFound = 1
                break
            }
        }
        return isFound
    }
    
    // in: varLibId, isVerbatimOrNonVerbatim
    func doesThisVarHaveVerbatimOrNonVerbatimInhomModel() { localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($o1)
        if (actSpecVar == nil) {
            // Not found
            return 0
        }
        if (!actSpecVar.isInhom) {
            return 0
        }
        if ($2) {
            return (actSpecVar.distFuncIdx == dfc.verbatimDistFuncIdx)
        } else {
            return (actSpecVar.distFuncIdx != dfc.verbatimDistFuncIdx)
        }
    }
    
    func doesAnyInhomVarRequirePython() { local isDmOrTapPart, isExportAssignedAndState, isFound localobj actSpecVar
        isDmOrTapPart = $1
        isExportAssignedAndState = $2
        isFound = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            // 1: "PARAMETER"
            if (actSpecVar.isInhom && actSpecVar.isDmOrTapPart == isDmOrTapPart && (actSpecVar.varLibId.varType == 1 || isExportAssignedAndState)) {    //
                if (dfc.doesDistFuncRequirePython(actSpecVar.distFuncIdx)) {                                                                            // Do not replace with one IF
                    // Don't replace with "return 1"
                    isFound = 1
                    break
                }
            }
        }
        return isFound
    }
    
    func doesAnyStochVarRequirePython() { local isDmOrTapPart, isExportAssignedAndState, isFound localobj actSpecVar
        isDmOrTapPart = $1
        isExportAssignedAndState = $2
        isFound = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            // 1: "PARAMETER"
            if (actSpecVar.isStoch && actSpecVar.isDmOrTapPart == isDmOrTapPart && (actSpecVar.varLibId.varType == 1 || isExportAssignedAndState)) {    //
                if (sfc.doesStochFuncRequirePython(actSpecVar.stochFuncIdx)) {                                                                          // Do not replace with one IF
                    // Don't replace with "return 1"
                    isFound = 1
                    break
                }
            }
        }
        return isFound
    }
    
    // in: varLibId
    // out: actSpecVarOrNil, (opt) idxOrMinus1
    obfunc findActiveSpecVar() { local numArg, idx localobj actSpecVar, nil
        numArg = numarg()
        if (numArg < 1 || numArg > 2) {
            codeContractViolation()
        }
        
        // Not many activeSpecVars-s, so hashless comparison works just fine
        for idx = 0, activeSpecVars.count() - 1 {
            actSpecVar = activeSpecVars.o(idx)
            if (actSpecVar.isEqual($o1)) {
                break
            }
        }
        
        if (idx == activeSpecVars.count()) {
            // Not found
            actSpecVar = nil
            idx = -1
        }
        
        if (numArg == 2) {
            $&2 = idx
        }
        
        return actSpecVar
    }
    
    // All next staff is private
    
    
    // in: varLibId
    // out: actSpecVar, (opt) isFoundOrCreated
    obfunc findOrCreateActiveSpecVar() { local numArg, isFound localobj actSpecVar, nil
        numArg = numarg()
        if (numArg < 1 || numArg > 2) {
            codeContractViolation()
        }
        
        actSpecVar = findActiveSpecVar($o1)
        isFound = (actSpecVar != nil)
        if (!isFound) {
            actSpecVar = new InhomAndStochTarget($o1)
            activeSpecVars.append(actSpecVar)
        }
        
        if (numArg == 2) {
            $&2 = isFound
        }
        
        return actSpecVar
    }
    
    // in: isDmOrTapPart, isInhomOrStoch
    func getNumInhomOrStochVars() { local isDmOrTapPart, isInhomOrStoch, numVars localobj actSpecVar
        isDmOrTapPart = $1
        isInhomOrStoch = $2
        numVars = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            if (actSpecVar.isDmOrTapPart != isDmOrTapPart) {
                continue
            }
            if (isInhomOrStoch) {
                if (!actSpecVar.isInhom) {
                    continue
                }
            } else {
                if (!actSpecVar.isStoch) {
                    continue
                }
            }
            numVars += 1
        }
        return numVars
    }
    
    proc correctCompIdxsAfterSplit() { local splitCompIdx localobj specVars, specVar
        specVars = $o1
        splitCompIdx = $2
        for eachItemInList(specVar, specVars) {
            if (!specVar.isDmOrTapPart) {
                continue
            }
            if (specVar.varLibId.compIdx > splitCompIdx) {
                specVar.varLibId.compIdx += 1
            }
        }
    }
    
    proc deleteSpecVarsForMergedComps() { local specVarIdx localobj specVars, delCompIdxs, specVar
        specVars = $o1
        delCompIdxs = $o2
        for (specVarIdx = specVars.count() - 1; specVarIdx >= 0; specVarIdx -= 1) {
            specVar = specVars.o(specVarIdx)
            if (!specVar.isDmOrTapPart) {
                continue
            }
            if (delCompIdxs.contains(specVar.varLibId.compIdx)) {
                specVars.remove(specVarIdx)
            }
        }
    }
    
    proc correctCompIdxsAfterMerge() { local oldCompIdx, newCompIdx localobj specVars, compIdxMapFromOldToNew, specVar
        specVars = $o1
        compIdxMapFromOldToNew = $o2
        for eachItemInList(specVar, specVars) {
            if (!specVar.isDmOrTapPart) {
                continue
            }
            oldCompIdx = specVar.varLibId.compIdx
            newCompIdx = compIdxMapFromOldToNew.x(oldCompIdx)
            specVar.varLibId.compIdx = newCompIdx
        }
    }
    
    proc applyAllRetrievedInhomModelsAndCommitAllChangesToLibrary() { localobj newActSpecVars, newInactSpecVars, newActSpecVar
        newActSpecVars = $o1
        newInactSpecVars = $o2
        
        // Apply all retrieved inhom models
        for eachItemInList(newActSpecVar, newActSpecVars) {
            if (newActSpecVar.isInhom) {
                newActSpecVar.restoreInhomogeneity()
            }
        }
        
        // Commit all the changes to the library
        concatenateTwoLists(activeSpecVars, newActSpecVars)
        concatenateTwoLists(inactiveSpecVars, newInactSpecVars)
    }
    
    iterator eachActTapVarMakeInactIfNeeded() { local actSpecVarIdx localobj newInactSpecVars, actSpecVar
        newInactSpecVars = $o3
        
        for (actSpecVarIdx = activeSpecVars.count() - 1; actSpecVarIdx >= 0; actSpecVarIdx -= 1) {
            actSpecVar = activeSpecVars.o(actSpecVarIdx)
            if (actSpecVar.isDmOrTapPart) {
                continue
            }
            
            $&1 = actSpecVar.varLibId.compIdx
            
            $&2 = 1
            iterator_statement
            if ($&2) {
                continue
            }
            
            newInactSpecVars.append(actSpecVar)
            activeSpecVars.remove(actSpecVarIdx)
        }
    }
    
    iterator eachInactTapVarMakeActIfNeeded() { local inactSpecVarIdx localobj newActSpecVars, inactSpecVar
        newActSpecVars = $o4
        
        for (inactSpecVarIdx = inactiveSpecVars.count() - 1; inactSpecVarIdx >= 0; inactSpecVarIdx -= 1) {
            inactSpecVar = inactiveSpecVars.o(inactSpecVarIdx)
            if (inactSpecVar.isDmOrTapPart) {
                continue
            }
            
            $&1 = inactSpecVar.varLibId.compIdx
            $s2 = inactSpecVar.mechName
            
            $&3 = 1
            iterator_statement
            if ($&3) {
                continue
            }
            
            newActSpecVars.append(inactSpecVar)
            inactiveSpecVars.remove(inactSpecVarIdx)
        }
    }
    
endtemplate InhomAndStochLibrary


proc createOrImportInhomAndStochLibrary() { localobj nil
    if (inhomAndStochLibrary == nil) {
        inhomAndStochLibrary = new InhomAndStochLibrary()
    } else {
        if (isBaseOrNanoStart) {
            codeContractViolation()
        }
        // Load data from the imported reduced template
        inhomAndStochLibrary = new InhomAndStochLibrary(inhomAndStochLibrary)
    }
}

createOrImportInhomAndStochLibrary()
