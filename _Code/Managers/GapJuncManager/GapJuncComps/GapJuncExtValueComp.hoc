
// !!!! just copied from SynPPComp: clean this up
    
begintemplate GapJuncExtValueComp
    
    public name, enumDmPpFk, isExtOrInt, enumPpRole, isMechVarTypeInhom, mechStds
    public isMechVarInhom, prepareVarsEditorHeader, getDistRange, getSecList, markMechDirty, updateStatsCurve, updateVerbatimModelCurve, applyInhomogeneity
    public isMechVarTypeInhom, mechStds, isMechDirty
    
    external mth, math, mcu
    external gjmAllGapJuncs, gapJuncGroups, tapGroup
    external /* !!! stringsEqual, */ codeContractViolation
    external enumGapJuncPpRoles
    external pyObj
    
    strdef name
    enumDmPpFk = -1
    isExtOrInt = -1
    enumPpRole = -1
    
    double isMechVarTypeInhom[1][1]     // 0/1 flags
    // !! would it make sense to create these MechanismStandard-s without 2nd ctor arg and get rid of 2nd dimension in this array?
    objref mechStds[1][1]
    double isMechDirty[1]               // 0/1 flags
    
    objref gjmAllGapJuncsOfThisType, gapJuncGroupOfThisType
    
    objref this
    
    
    proc init() { local numArg, numMechs, mechIdx, varType, varTypeIdx localobj impRedObj, actFirstPpOrNil, mechStd, nil
        strdef actPpName, thisPpName
        
        name = $s1
        
        /* !!!!
        numArg = numarg()
        if (numArg == 1) {
            // Load data from the imported reduced template (part 1)
            impRedObj = $o1
            name = impRedObj.name
        } else if (numArg == 1) {
            name = $s1
        } else {
            codeContractViolation()
        }
        */
        
        enumDmPpFk = 2
        isExtOrInt = 1
        enumPpRole = enumGapJuncPpRoles.extValue    // !!!!
        
        gjmAllGapJuncsOfThisType = gjmAllGapJuncs[isExtOrInt]
        gapJuncGroupOfThisType = gapJuncGroups[isExtOrInt]
        
        numMechs = 1
        
        double isMechVarTypeInhom[numMechs][3]  // 0/1 flags
        objref mechStds[numMechs][3]            // 0: "PARAMETER", 1: "ASSIGNED", 2: "STATE"
        double isMechDirty[numMechs]            // 0/1 flags
        
        mechStd = new FakeMechanismStandardForExtValue()
        
        /* !!!
        if (stringsEqual(thisPpName, actPpName) && actFirstPpOrNil != nil) {
            // It's a code contract that all the gap juncs have homogeneous PP-s at the time of new GapJuncPPComp-s construction
            // (but this does not apply to "start with BrainCell export" mode)
            mechStd.in(actFirstPpOrNil)
        }
        */
        
        mechStds[0][0] = mechStd
        
        // !! search for inhomogeneities in the vars
        
        if (impRedObj == nil) {
            return
        }
        
        // Load data from the imported reduced template (part 2)
        
        mechIdx = impRedObj.mechIdx
        for varType = 1, 1 {    // 1: "PARAMETER", 2: "ASSIGNED", 3: "STATE"
            varTypeIdx = mth.convertVarTypeToVarTypeIdx(varType)
            mechStd = impRedObj.mechStds[mechIdx][varTypeIdx]
            if (mechStd != nil) {
                mechStds[mechIdx][varTypeIdx] = mechStd     // Replacing it just to have NaN-s for all inhom vars
                mcu.setOneIfNeededIn_isMechVarTypeInhom(this, mechIdx, varType)
            }
        }
    }
    
    // !! code dupl. with MechComp
    func isMechVarInhom() { local mechIdx, varType, arrayIndex, varTypeIdx
        strdef varName
        mechIdx = $1
        varType = $2
        varName = $s3
        arrayIndex = $4
        if (varType == -1) {    // -1: "GLOBAL"
            return 0
        }
        varTypeIdx = mth.convertVarTypeToVarTypeIdx(varType)
        return math.isNaN(mechStds[mechIdx][varTypeIdx].get(varName, arrayIndex))
    }
    
    // !! mostly code dupl. with MechComp
    // !! it would be better to move this to MechTypeHelper
    proc prepareVarsEditorHeader() { local mechIdx, varType
        strdef mechName
        
        mechIdx = $1
        varType = $2    // !!! just a placeholder
        
        mth.getMechName(2, mechIdx, mechName)
        sprint($s3, "%s in %s:", mechName, name)
    }
    
    proc getDistRange() {
        gapJuncGroupOfThisType.getDistRange(&$&1, &$&2)
    }
    
    obfunc getSecList() {
        return gapJuncGroupOfThisType.getSecList()
    }
    
    proc markMechDirty() { local mechIdx
        mechIdx = $1
        isMechDirty[mechIdx] = 1
    }
    
    proc updateStatsCurve() { local yMin, yMax, varType, arraySize, arrayIndex, y localobj graph, gapJunc
        strdef mechName, varName, actPpName
        
        graph = $o1
        yMin = $&2
        yMax = $&3
        mechName = $s4
        varType = $5
        varName = $s6
        arraySize = $7  // Just a placeholder
        arrayIndex = $8
        
        gapJuncGroupOfThisType.getPpNameOrEmpty(actPpName)
        if (!pyObj.ms_doesGapJuncHavePtr(actPpName)) {
            // The actual gap junctions don't have PPs with this !!!role!!! or use different PPs
            return
        }
        
        for tapGroup.updateStatsCurveIter(gapJunc, gjmAllGapJuncsOfThisType, graph, &y, &yMin, &yMax) {
            y = gapJunc.extValue
        }
        
        $&2 = yMin
        $&3 = yMax
    }
    
    proc updateVerbatimModelCurve() {
        // It's a code contract that all the gap juncs have homogeneous PP-s at the time of new GapJuncPPComp-s construction
        codeContractViolation()
    }
    
    // Keep in sync with !!!ReducedGapJuncPPComp2!!!.applyInhomogeneity
    proc applyInhomogeneity() { local varType, arraySize, arrayIndex, y localobj distFuncHelper, mechStd, gapJunc, thisPp
        strdef mechName, varName
        
        mechName = $s1
        varType = $2
        varName = $s3
        arraySize = $4  // Just a placeholder
        arrayIndex = $5
        distFuncHelper = $o6
        
        if (varType == -1) {    // -1: "GLOBAL"
            codeContractViolation()
        }
        
        mechStd = new FakeMechanismStandardForExtValue(mechName, varType)
        
        for tapGroup.applyInhomogeneityIter(gapJunc, gjmAllGapJuncsOfThisType, distFuncHelper) {
            // !!!! simplify this
            thisPp = gapJunc.getPointProcess(enumPpRole)
            mechStd.in(thisPp)
            y = distFuncHelper.calculateAt(gapJunc.dist)
            // !! BUG: "variable_domain" used in "MechanismStandard.panel()" is ignored in "MechanismStandard.set()" and "MechanismStandard.out()",
            //      so we can use any invalid value here without even a warning
            mechStd.set(varName, y, arrayIndex)
            mechStd.out(thisPp)
        }
    }
    
endtemplate GapJuncExtValueComp
